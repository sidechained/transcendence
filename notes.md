YES	Can send https curl requests from inside the backend container
YES	Can send https curl requests from host machine 
YES Create shared volume to hold certificate
YES	Can access frontend over https
NO	Can send https api requests javascript front end, because of
[2023-11-21 10:35:20 +0000] [12] [WARNING] Invalid request from ip=192.168.112.1: [SSL: SSLV3_ALERT_CERTIFICATE_UNKNOWN] sslv3 alert certificate unknown (_ssl.c:2559)
NO	Django admin dashboard causes this error, because of
[2023-11-21 09:09:25 +0000] [13] [WARNING] Invalid request from ip=192.168.32.1: [SSL: SSLV3_ALERT_CERTIFICATE_UNKNOWN] sslv3 alert certificate unknown (_ssl.c:2559)

/usr/local/share/ca-certificates/
/home/grm/.local/share/mkcert contains:
rootCA-key.pem  rootCA.pem

i have four files generated by mkcert in my Docker , which do i need to 
localhost-key.pem
localhost.pem
rootCA.pem
rootCA-key.pem

# Testing with mkcert and firefox

sudo apt install mkcert
mkcert -install

"Created a new local CA üí•
The local CA is now installed in the system trust store! ‚ö°Ô∏è
The local CA is now installed in the Firefox and/or Chrome/Chromium trust store (requires browser restart)! ü¶ä"

trashed the files in ~/.local/share/mkcert/
Copied my rootCA* from transdence/ssl-keys/ into ~/.local/share/mkcert/

Open a Mozilla Firefox browser.
Enter ‚Äúabout:preferences#privacy‚Äù in the address bar, and then press Enter.
Locate and click the View Certificates option.
Select Authorities tab, and then click Import.
Right click to show hidden files
Navigate to ~/.local/share/mkcert/
Select the CA that you want to import (rootCA.pem), and then click Open.
Select Trust this CA to identify websites in the Downloading Certificate window.
Click OK to import the CA into the browser, and then close the window.
Restart Firefox. 

Still doesn't work! [WARNING] Invalid request from ip=172.20.0.1: [SSL: TLSV1_ALERT_UNKNOWN_CA] tlsv1 alert unknown ca (_ssl.c:2559)

But I didn't install the local certs anywhere

# How is curl managing to do it?
It uses three certs, so far I'm just using one

curl --cert ./ssl-keys/localhost.pem --key ./ssl-keys/localhost-key.pem --cacert ./ssl-keys/rootCA.pem -X POST -H "Content-Type: application/json" -d '{"player1_name": "John", "player1_points": 10, "player2_name": "Jane", "player2_points": 8}' https://localhost:8000/api/add_game_data/

# Q: is my javascript using the certificate?

If your website is served over HTTPS (secured with an SSL/TLS certificate), and you make API calls from your JavaScript code to a Django backend using relative URLs or URLs with the same domain, protocol, and port, those API calls will inherit the security context of the main page. In other words, the requests will also be made over HTTPS.

When making requests from a secure webpage (HTTPS) to the same domain, the browser will automatically use the same security context, including the SSL/TLS certificate. This ensures that the data exchanged between your frontend and backend is encrypted and secure.

It's important to note that if you are making requests to a different domain or using absolute URLs with a different protocol (e.g., HTTP instead of HTTPS), the browser might block the request or issue a warning due to security restrictions known as the Same-Origin Policy. In such cases, you might need to handle CORS (Cross-Origin Resource Sharing) appropriately on the server side.

# Does my browser use both the cert, key and ca? If not then how should it?

Client Certificates in the Browser:
In your JavaScript code, you're not specifying any client certificates. If your server requires client authentication, you may need to handle it differently in the browser. Usually, client certificates are managed by the browser itself. Ensure that the client certificate is properly configured on your browser.

# https://javascript.info/fetch-crossorigin
